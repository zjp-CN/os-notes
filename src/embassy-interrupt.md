# embassy: interrupt

预选资料：

* [embedded-book interrupts]
* [cortex_m_rt::interrupt]
* [embedded-book exceptions]
* [cortex_m_rt::exception]

[embedded-book interrupts]: https://docs.rust-embedded.org/book/start/interrupts.html
[cortex_m_rt::interrupt]: https://docs.rs/cortex-m-rt/latest/cortex_m_rt/attr.interrupt.html
[embedded-book exceptions]: https://docs.rust-embedded.org/book/start/exceptions.html
[cortex_m_rt::exception]: https://docs.rs/cortex-m-rt/latest/cortex_m_rt/attr.exception.html

# 名词解释

结果来自 kimi (AI)，不保证完全准确。

## SVD 

SVD（System View Description）文件是CMSIS（Cortex Microcontroller Software Interface Standard）的一部分，用于描述微控制器的系统视图。它包含了微控制器系统中的外设和内核的详细描述，特别是内存映射的寄存器。SVD文件是一个XML格式的文本文件，定义了如何详细描述微控制器的硬件资源，包括外设的高级功能描述和寄存器中单个位字段的定义和操作。

SVD文件通常由芯片供应商开发和维护，并作为CMSIS设备系列包的一部分分发。工具供应商，如Keil或IAR，使用这些文件在其调试器中提供外设的调试视图，从而简化了嵌入式软件的开发过程，特别是对于基于ARM Cortex-M系列处理器的系统。

SVD文件的内容非常详细，与芯片的数据手册内容相匹配，可以用于生成芯片的头文件定义。在调试时，使用SVD文件可以直观地查看和操作寄存器的值、状态和中断配置等。

此外，SVD文件还可以于自动化逆向分析ARM固件，通过解析这些文件，可以为多种不同的微控制器自动生成外设结构和存储器映射表，从而简化了固件的逆向过程。尽管CMSIS主要针对ARM Cortex架构，但其开放性使得其他架构也可以模仿使用。

在实际应用中，可以通过工具如`sdk-npi-enablement-tool`生成SVD文件和芯片头文件，这些工具帮助开发者从UM文档中提取寄存器分布信息，并生成所需的SVD文件和头文件，进而助微控制器的软件开发。


## Reentrancy (可重入性)

在计算机科学中，"Reentrancy"（可重入性）是一个重要的概念，它指的是一个函数或代码块可以在任何时刻被中断，并能够安全地再次进入执行的能力，而不会依赖于任何临时状态信息。这个概念在硬件和操作系统中都非常重要，具体表现如下：

* 硬件中的可重入性

  1. **中断处理**：在硬件层面，可重入性通常与中断处理相关。中断服务例程（ISR）必须设计为可重入的，因为它们以在任何时间点被触发，包括在执行另一个中断服务例程的过程中。

  2. **寄存器使用**：硬件中断处理要求使用特定的寄存器，以避免破坏当前程序的状态。这意味着在中断服务例程中，任何需要保存的寄存器状态必须被保存和恢复。

  3. **状态保存**：在中断发生时，硬件需要保存当前的执行状态，以便在中断处理完成后可以恢复执行。这通常涉及到将程序计数器和其他状态信息保存到堆栈中。

* 操作系统中的可重入性

  1. **系统调用**：操作系统的系统调用必须设计为可重入的，因为它们可能会在执行过程中被中断，并且在中断处理结束后需要继续执行。

  2. **线程安全**：在多线程环境中，操作系统的代码需要保证线程安全，这意味着任何共享资源的访问都需要通过同步机制来保护，以避免竞态条件。

  3. **信号处理**：类似于中断，操作系统中的信号处理也需要是可重入的。信号处理函数应该避免使用全局变量和静态数据，以确保它们可以在任何时间点安全地执行。

  4. **内核模块**：操作系统的内核模块和驱动程序在设计时也需要考虑到可重入性，以保它们可以在中断上下文中安全地调用。

  5. **资源管理**：操作系统需要管理各种资源，如内存、文件、设备等。资源管理器必须设计为可重入的，以确保在中断或多线程环境中资源的正确分和释放。

* 可重入性的重要性

  - **提高可靠性**：确保系统在面对意外的中断时能够正确地恢复状态，提高系统的可靠性和稳定性。
  - **支持多任务**：在多任务环境中，可重入性允许系统同时处理多个任务，而不会相互干扰。
  - **增强安全性**：通过确保代码在中断和多线程环境中的安全执行，防止数据损坏和安全漏洞。

总的来说，可重入性是设计硬件和操作系统时的一个重要考虑素，它确保了系统在面对中断和并发执行时的稳定性和安全性。

> 问：那么不可重入的设计具体是什么样？
> 
> 不可重入的设计指的是代码或函数在执行过程中，如果被再次调用或中断，可能会导致不可预测的行为或错误。这种设计通常缺乏必要的保护措施，如资源锁定、状态保存等。以下是一些不可重入设计的具体特征：
> 
> 1. **使用全局变量**：不可重入的函数经常依赖于全局变量来存储状态信息。当多个线程或中断服务例程（ISR）访问这些全局变量时，可能会导致数据竞争和不一致。
> 
> 2. **修改静态或局部状态**：函数内部使用静态变量或修改局部变量的状态，这些状态在函数调用之间没有被重置或保存，导致再次进入函数时无法确定状态。
> 
> 3. **缺乏同步机制**：在多线程环境中，如果共享资源的访问没有通过互斥锁、信号量等同步机制进行保护，就可能导致竞态条件和数据不一致。
> 
> 4. **中断服务例程（ISR）中的错误使用**：如果ISR中使用了不可重入的函数，或者ISR本没有设计为可重入，那么在ISR执行期间如果再次发生中断，可能会导致不可预测的行为。
> 
> 5. **资源未释放**：在函数或代码块中分配了资源（如内存、文件句柄等），但在函数结束前没有释放这些资源，导致资源泄漏。
> 
> 6. **依赖外部状态**：函数执行依赖于外部环境的状态，如依赖于特定的硬件状态或操作系统的状态，而这些状态可能在函数执行期间发生变化。
> 
> 7. **递归调用**：在某些情况下，递归调用本身并不是不可重入的，但如果递归函数使用了一些不可重入的资源或状态，那么这种递归调用就可能变得不可重入。
> 
> 8. **信号处理函数**：在Unix-like系统中，如果信号处理函数不是可重入的，那么在处理信号时可能会调用其他不可重入的函数，导致问题。
> 
> 9. **系统调用**：如果系统调用不是设计为可重入的，那么在执行系统调用的过程中被中断，可能会导致系统状态不一致。
> 
> 不可重入的设计可能会导致以下问题：
> 
> - **数据损坏**：由于多个执行线程或中断服务例程同时修改共享数据，导致数据损坏。
> - **死锁**：由于资源分配不当或同步机制缺失，导致系统在等待资源时陷入死锁状态。
> - **性能问题**：由于资源未及时释放或错误的状态管理，导致系统性能下降。
> - **系统崩溃**：在极端情况下，不可重入的设计可能导致系统崩溃或不可恢复的错误。
> 
> 为了避免这些问题，设计时应尽量遵循可重入的原则，确保代码的健壮性和可靠性。

## Semihosting

Semihosting 是一种在嵌入式开发中常用的调试技术，它允许目标设备（如微控制器）上的程序与主机计算机进行通信。这种技术主要用于在开发过程中提供调试信息、加载文件、执行系统调用等，而不需要实际的操作系统支持。以下是 Semihosting 的一些关键特点：

1. **调试接口**：Semihosting 通过调试器与目标设备之间的接口实现，通常使用 JTAG 或 SWD（Serial Wire Debug）等调试接口。

2. **标准 I/O 重定向**：Semihosting 允许程序的标准输入输出（如 `printf`）被重定向到主机计算机的控制台或文件中，便于开发者查看程序的输出。

3. **系统调用**：它提供了一种机制来执行系统调用，如文件操作（打开、读取、写入、关闭文件）和环境变量访问等，这些调用在没有操作系统的裸机环境中通常是不可用的。

4. **内存管理**：Semihosting 允许程序在目标设备和主机计算机之间传输数据，例如加载或保存二进制数据块。

5. **错误处理**：Semihosting 调用可以返回错误码，以指示操作成功或失败的原因。

6. **性能影响**：由于 Semihosting 依赖于调试接口与主机计算机的通信，因此在程序运行时使用 Semihosting 调用可能会引入显著的性能开销。

7. **安全性**：在某些应用场景中，使用 Semihosting 可能会带来安全风险，因为它允许程序与外部计算机通信，可能会被用于攻击目的。

8. **工具链支持**：不同的编译器和调试器可能对 Semihosting 的支持程度不同，开发者需要根据所使用的工具链查阅相应的文档。

9. **应用场景**：Semihosting 主要用于开发和调试阶段，不推荐在生产环境中使用，因为它依赖于调试接口，且可能影响程序的性能和安全性。

10. **配置和使用**：使用 Semihosting 通常需要在编译器或链接器设置中进行配置，以启用相应的支持，并在代码中使用特定的宏或函数调用来实现 Semihosting 功能。

Semihosting 是嵌入式开发中一个非常有用的工具，特别是在没有操作系统支持的情况下，它为开发者提供了一种与目标设备交互的有效方式。然而，由于其对性能和安全性的潜在影响，应当谨慎使用，并在产品发布前从最终固件中移除相关代码。

## OpenOCD

OpenOCD是一个开源的软件，用于提供对多种微控制器和处理器的调试、内联追踪和系统编程支持。它广泛应用于嵌入式系统的开发中，与GDB（GNU Debugger）等调试器协同工作，提供了一系列功能来帮助开发者测试和调试他们的程序。以下是OpenOCD的一些关键特性：

1. **多平台支持**：OpenOCD可以在多种操作系统上运行，包括Linux、Windows和macOS。

2. **多处理器支持**：它支持多种架构的处理器，如ARM、AVR32、MIPS、MicroBlaze、Nios II、PowerPC、RISC-V等。

3. **JTAG/SWD接口**：OpenOCD通过JTAG（Joint Test Action Group）或SWD（Serial Wire Debug）接口与目标设备通信。

4. **GDB远程服务器**：OpenOCD作为一个远程服务器运行，GDB客户端可以连接到这个服务器来进行调试。

5. **脚本语言**：OpenOCD使用Tcl（Tool Command Language）脚本语言来配置和扩展其功能。

6. **配置文件**：它使用配置文件来定义目标设备的调试接口和内存映射。

7. **固件库**：OpenOCD带有一套固件库，用于支持不同的目标设备。

8. **高级调试功能**：支持断点、观察点、数据比较、复杂表达式计算等高级调试功能。

9. **编程和烧录**：除了调试外，OpenOCD还可以用于编程和烧录固件到目标设备。

10. **社区支持**：作为一个开源项目，OpenOCD得到了一个活跃的社区支持，不断有新的功能和改进被加入。

11. **可扩展性**：OpenOCD的插件架构允许开发者根据自己的需求添加新的功能。

12. **文档和资源**：OpenOCD有详细的文档和在线资源，帮助开发者学习和使用这个工具。

使用OpenOCD时，通常需要以下步骤：

- 安装OpenOCD软件。
- 根据目标设备配置OpenOCD（可能需要编写或修改配置文件）。
- 使用适当的接口（如JTAG或SWD）将目标设备连接到计算机。
- 启动OpenOCD服务器。
- 使用GDB或其他调试器连接到OpenOCD服务器。
- 开始调试或编程过程。

OpenOCD是一个功能强大的工具，对于嵌入式系统开发者来说，是不可或缺的一部分。
